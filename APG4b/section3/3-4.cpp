/*
構造体を用いることで、複数の型をまとめた新しい型を定義することができる
struct 構造体名 {
    型1 メンバ変数名1
    ...
};

以下のように初期化する
構造体名 変数名;

また、次のようにしてもよい
auto 変数名 = 構造体名();

宣言と同時に、メンバ変数の初期化を行う場合
構造体名 オブジェクト名 = {メンバ変数1の値,  ...(必要な分だけ書く)};

コンストラクタも定義できる
struct 構造体名 {
  // コンストラクタ
  構造体名() {
    // コンストラクタの内容
  }
};
コンストラクタは複数定義でき、与える引数の型や引数の個数によって
自動的に呼び分けることができる。

演算子のオーバーロード
新たに定義した構造体型のオブジェクトに対してc++の演算子を使えるように
することができる。この機能を演算子オーバーロードという。
struct MyPair {
  int x;
  string y;
  // 別のMyPair型のオブジェクトをとって、x, yにそれぞれ+したものを返す
  // +演算子をオーバーロード
  MyPair operator+(const MyPair &other) {
    MyPair ret;
    ret.x = x + other.x;  // ここではint型の+演算子が呼ばれる
    ret.y = y + other.y;  // ここではstring型の+演算子が呼ばれる
    return ret;
  }
};
+演算子をオーバーロードする場合は次のように定義
struct 構造体名 {
  返り値の型 operator+(引数の型 引数) {
    // 処理内容
  }
};

他の演算子も同様にオーバーロードすることができます。 
メンバ関数として演算子オーバーロードを定義する場合、次のようにします。
struct 構造体の型 {
  返り値の型 operator演算子(引数の型 引数) {
    // 処理内容
  }
};



*/